Autocompletion for locations. Building the display name for a location was
kind of challenging at first. This is what we came up with, and it is a
very good example of using macros for making chaining of function calls
more readable. The default Clojure syntax would require a lot of nested
expressions where it becomes difficult to identify the arguments of
the called functions.

(defn display-name [location]
  (let [{:keys [name]} location
        {:keys [address city]} (:location location)]
    (->> (filter identity [name address city])
         (interpose ", ")
         (apply str)
         (pr-str))))

(defroutes location-routes
  (GET "/groups/:group-id/locations" [group-id :as req]
       (-> (if-let [term (-> req :params :term)]
             (map display-name (locations/find-locations-by-prefix group-id term))
             [])
           (sort)
           (json-response))))


This is a typical code snippet from our persistence layer. We are using Redis
for storing our data, and so, as with many NoSQL databases, a lot of the
data aggregation needs to be done by the application, but as this snippet
shows, this can be handled quite elegantly with a language like Clojure with 
all its functional concepts. Also, as you can see, we just serialize and
deserialize (using read-string) Clojure data structures when storing or 
retrieving them from Redis, instead of having to use a "non-native" data 
representation format like JSON.

(defn get-teams
  "Returns all teams of the given group."
  [group-id]
  (let [team-names (redis/smembers db (teams-key group-id))]
    (map read-string (apply redis/mget db (map (partial team-key group-id) team-names)))))


This is Lunjure's complete chat Websocket handler code. It
gracefully handles disconnects, notifies all users in the room
about entering and leaving users, sends the recent chat history to
entered users and wires their connections with the message handler
- all in 12 lines of Clojure!

(defn user-group-chat-handler [group-channel group-id user]
  (fn [user-channel handshake]
    (siphon group-channel user-channel)
    (on-closed user-channel (partial broadcast-message group-channel group-id user {:type :exit}))
    (send-history user-channel group-id)
    (broadcast-message group-channel group-id user {:type :enter})
    (let [user-channel (map* (partial enrich-message user) user-channel)]
      (-> (fork user-channel)
          (receive-in-order (partial db/add-message! group-id)))
      (-> (map* (comp pr-str handle-message) user-channel)
          (siphon  group-channel)))))
