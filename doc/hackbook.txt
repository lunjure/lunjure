Autocompletion for locations:

(defn display-name [location]
  (let [{:keys [name]} location
        {:keys [address city]} (:location location)]
    (->> (filter identity [name address city])
         (interpose ", ")
         (apply str)
         (pr-str))))

(defroutes location-routes
  (GET "/groups/:group-id/locations" [group-id :as req]
       (-> (if-let [term (-> req :params :term)]
             (map display-name (locations/find-locations-by-prefix group-id term))
             [])
           (sort)
           (json-response))))


From our persistence code:

(defn get-teams
  "Returns all teams of the given group."
  [group-id]
  (let [team-names (redis/smembers db (teams-key group-id))]
    (map read-string (apply redis/mget db (map (partial team-key group-id) team-names)))))


This is Lunjure's complete chat Websocket handler code. It
gracefully handles disconnects, notifies all users in the room
about entering and leaving users, sends the recent chat history to
entered users and wires their connections with the message handler
- all in 12 lines of Clojure!

(defn user-group-chat-handler [group-channel group-id user]
  (fn [user-channel handshake]
    (siphon group-channel user-channel)
    (on-closed user-channel (partial broadcast-message group-channel group-id user {:type :exit}))
    (send-history user-channel group-id)
    (broadcast-message group-channel group-id user {:type :enter})
    (let [user-channel (map* (partial enrich-message user) user-channel)]
      (-> (fork user-channel)
          (receive-in-order (partial db/add-message! group-id)))
      (-> (map* (comp pr-str handle-message) user-channel)
          (siphon  group-channel)))))
